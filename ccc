#!/usr/bin/env python2

"""
Command line tool for CoreCommerce access.

TODO
----
* test list+fields
* test show
* test update
"""

from __future__ import print_function
import ConfigParser
import argparse
import cctools
import os
import re
import sys

HEADER_MAP = {
    "Available": "Avail",
    "Discontinued Item": "Discd",
    "Track Inventory": "TrkInv",
    "Inventory Level": "InvLvl",
    "Category Id": "CatId",
    "Product SKU": "PrdSKU",
    "Required": "QuesReq",
    "Track Inventory": "TrkInv",
    "Question Enabled": "QEnab",
    "Answer Sort Order": "Sort",
    "Inventory Level": "InvLvl",
    "Answer Input Type": "AnsType"
}

class ArgumentError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)


def output_csv(args, records, fields, header_map=None):
    """Output records in CSV format."""
    delim = args.delimiter

    # Output header.
    if header_map == None:
        header_map = dict()
    print(delim.join([header_map.get(field, field) for field in fields]))

    # Output records.
    for record in records:
        print(
            delim.join(
                [cctools.html_to_plain_text(record[field]) for field in fields]
            )
        )


def output_table_divider(col_widths):
    print(
        "+" + "+".join(
            "-" * (col_width + 2)
            for col_width in col_widths
        ) + "+"
    )


def output_table_row(row, col_widths, mapping=None):
    if mapping == None:
        mapping = dict()
    print(
        "| " + " | ".join(
            "%-*s" % (col_widths[col], mapping.get(field, field))
            for col, field in enumerate(row)
        ) + " |"
    )


def output_table(records, fields, header_map=None):
    if header_map == None:
        header_map = dict()

    # Determine the column widths.
    col_widths = list()
    for field in fields:
        col_widths.append(len(header_map.get(field, field)))
    for record in records:
        for col, field in enumerate(fields):
            col_widths[col] = max(col_widths[col], len(str(record[field])))

    # Pretty print the records to the output.
    output_table_divider(col_widths)
    output_table_row(fields, col_widths, header_map)
    output_table_divider(col_widths)
    for row, record in enumerate(records):
        output_table_row(
            [cctools.html_to_plain_text(record[field]) for field in fields],
            col_widths
        )
    output_table_divider(col_widths)


def output_records(args, records, fields, header_map=None):
    if args.format == "csv":
        output_csv(args, records, fields, header_map)
    elif args.format == "table":
        output_table(records, fields, header_map)


def reverse_lookup_header_map(header_map, value):
    """Return key from header_map that maps to value."""
    for key in header_map:
        if value == header_map[key]:
            return key
    return None


def adjust_field_list(fields, args, header_map):
    """Add and remove fields from field list."""

    # Remove fields specified by --del-field.
    if args.del_fields:
        for del_field in args.del_fields:
            if del_field == "*":
                del fields[:]
            elif del_field in fields:
                fields.remove(del_field)
            else:
                # Try the mapped form.
                del_field2 = reverse_lookup_header_map(header_map, del_field)
                if del_field2 in fields:
                    fields.remove(del_field2)
                else:
                    raise ArgumentError(
                        "field '{}' to delete not found".format(del_field)
                    )

    # Add fields specified by --add-field.
    if args.add_fields:
        for add_field in args.add_fields:
            if add_field in fields:
                raise ArgumentError(
                    "field '{}' to add already in field list".format(add_field)
                )
            else:
                fields.append(add_field)


def action_list(args, cc_browser):
    """List objects of a type."""
    if args.obj_type == "product":
        products = cc_browser.get_products()
        if args.filter:
            reo = re.compile(args.filter, re.IGNORECASE)
            products = [
                p for p in products
                if reo.search(p["SKU"]) or reo.search(p["Product Name"])
            ]
        products = sorted(products, key=lambda x: x["SKU"])
        fields = [
            "SKU",
            "Product Name",
            "Cost",
            "Price",
            "Available",
            "Discontinued Item",
            "Track Inventory",
            "Inventory Level",
            "Teaser"
        ]
        adjust_field_list(fields, args, HEADER_MAP)
        output_records(args, products, fields, HEADER_MAP)
    elif args.obj_type == "category":
        categories = cc_browser.get_categories()
        categories = sorted(categories, key=lambda x: x["Sort"])
        fields = ["Category Id", "Category Name", "Sort"]
        adjust_field_list(fields, args, HEADER_MAP)
        output_records(args, categories, fields, HEADER_MAP)
    elif args.obj_type == "personalization":
        personalizations = cc_browser.get_personalizations()
        personalizations = sorted(
            personalizations,
            key=cc_browser.personalization_sort_key
        )
        fields = [
            "Product SKU",
            "SKU",
            "Product Name",
            "Question|Answer",
            "Required",
            "Track Inventory",
            "Question Enabled",
            "Answer Sort Order",
            "Inventory Level",
            "Answer Input Type",
            "Main Photo"
        ]
        output_records(args, personalizations, fields, HEADER_MAP)


def action_list_fields(args, cc_browser):
    """List fields of a type."""
    if args.obj_type == "product":
        products = cc_browser.get_products()
        field_names = sorted(products[0].keys())
    elif args.obj_type == "category":
        categories = cc_browser.get_categories()
        field_names = sorted(categories[0].keys())
    elif args.obj_type == "personalization":
        personalizations = cc_browser.get_personalizations()
        field_names = sorted(personalizations[0].keys())
    fields = ["Field Name"]
    records = list()
    for field_name in field_names:
        records.append({"Field Name": field_name})
    output_records(args, records, fields)


def find_object(args, cc_browser):
    """Return an object iff there is one object matched by spec."""
    if args.obj_type == "product":
        objects = cc_browser.get_products()
        keys = ["SKU", "Product Name"]
    elif args.obj_type == "category":
        objects = cc_browser.get_categories()
        keys = ["Category Name"]
    elif args.obj_type == "personalization":
        objects = cc_browser.get_personalizations()
        keys = ["Question|Answer"]

    found_obj = None
    for obj in objects:
        for key in keys:
            if obj[key].startswith(args.spec):
                if found_obj:
                    raise ArgumentError(
                        "'{}' does not uniquely select a {}".format(
                            args.spec,
                            args.obj_type
                        )
                    )
                found_obj = obj
    if found_obj == None:
        raise ArgumentError(
            "No {} matches '{}' = '{}'".format(
                args.obj_type,
                "' or '".join(keys),
                args.spec
            )
        )

    return found_obj


def print_obj(obj, key):
    """Print obj[key] if key is defined, otherwise print entire dict."""
    if key:
        print(obj[key])
    else:
        for key, value in obj.items():
            print("{}: {}".format(key, value))


def action_show(args, cc_browser):
    """Show attributes of a specific object."""
    object = find_object(args, cc_browser)
    print_obj(object, args.key)


def action_update(args, cc_browser):
    """Update attributes of a specific object."""
    object = find_object(args, cc_browser)
    for keyval in args.keyvals:
        split_key_value = keyval.split("=")
        if len(split_key_value) != 2:
            raise ArgumentError("Invalid KEY=VALUE '{}'".format(keyval))
        key = split_key_value[0]
        if not cc_browser.is_valid_product_update_key(key):
            raise ArgumentError(
                "Invalid key '{}'. Only {} can be modified".format(
                    key,
                    cc_browser.get_product_update_keys()
                )
            )
        value = split_key_value[1]
        #print("{} {} {}->{}".format(object["SKU"], key, object[key], value))
        cc_browser.update_product(object["SKU"], key, value)


def action_refresh(args, cc_browser):
    """Refresh CoreCommerce object cache."""
    cc_browser.get_products()
    cc_browser.get_categories()
    cc_browser.get_personalizations()


def add_format_args(arg_parser):
    """Add formatting args to arg_parser."""
    arg_parser.add_argument(
        "--format",
        choices=["csv", "table"],
        default="table",
        help="output format [csv, table] (default=%(default)s)"
    )
    arg_parser.add_argument(
        "--delimiter",
        dest="delimiter",
        metavar="DELIM",
        default="|",
        help="output CSV delimiter (default=%(default)s)"
    )


def add_obj_type_argument(arg_parser):
    """Add object type argument to arg_parser."""
    # TODO: allow abbreviation
    # Any object that supports the in operator can be passed as the
    # choices value, so a custom container is supported.
    #if "product".startswith(arg) and len(arg) > 1:
    #    return "product"
    #elif "category".startswith(arg):
    #    return "category"
    #elif "personalization".startswith(arg) and len(arg) > 1:
    #    return "personalization"
    #else:
    #    raise ArgumentError("invalid object type '{}'".format(arg))
    arg_parser.add_argument(
        "obj_type",
        choices=["product", "category", "personalization"],
        help="object type"
    )


def main():
    """main"""
    default_config = os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        "cctools.cfg"
    )

    arg_parser = argparse.ArgumentParser(
        description="Command line tool for CoreCommerce access."
    )
    arg_parser.add_argument(
        "--config",
        metavar="FILE",
        default=default_config,
        help="configuration filename (default=%(default)s)"
    )
    arg_parser.add_argument(
        "--cache-ttl",
        metavar="SEC",
        type=int,
        default=3600,
        help="cache TTL (default=%(default)i)"
    )
    arg_parser.add_argument(
        "--format",
        choices=["csv", "table"],
        default="table",
        help="output format [csv, table] (default=%(default)s)"
    )
    arg_parser.add_argument(
        "--delimiter",
        dest="delimiter",
        metavar="DELIM",
        default="|",
        help="output CSV delimiter (default=%(default)s)"
    )
    arg_parser.add_argument(
        "--verbose",
        action="store_true",
        default=False,
        help="display progress messages"
    )
    subparsers = arg_parser.add_subparsers(title="sub-commands")

    # Add list sub-command.
    list_parser = subparsers.add_parser("list", help="List objects")
    list_parser.set_defaults(func=action_list)
    list_parser.add_argument(
        "--add-field",
        action="append",
        dest="add_fields",
        metavar="FLD",
        help="additional field to report"
    )
    list_parser.add_argument(
        "--del-field",
        action="append",
        dest="del_fields",
        metavar="FLD",
        help="remove field from report"
    )
    list_parser.add_argument(
        "--filter",
        dest="filter",
        metavar="RE",
        help="filter items"
    )
    add_format_args(list_parser)
    add_obj_type_argument(list_parser)

    # Add list_fields sub-command.
    list_fields_parser = subparsers.add_parser("list_fields", help="List object fields")
    list_fields_parser.set_defaults(func=action_list_fields)
    add_format_args(list_fields_parser)
    add_obj_type_argument(list_fields_parser)

    # Add show sub-command.
    show_parser = subparsers.add_parser("show", help="List key, values of an object")
    show_parser.set_defaults(func=action_show)
    add_obj_type_argument(show_parser)
    show_parser.add_argument(
        "spec",
        metavar="SPEC",
        help="object selector"
    )
    show_parser.add_argument(
        "key",
        metavar="KEY",
        nargs="?",
        help="optional specific key to show"
    )

    # Add update sub-command.
    update_parser = subparsers.add_parser("update", help="Update values of an object")
    update_parser.set_defaults(func=action_update)
    add_obj_type_argument(update_parser)
    update_parser.add_argument(
        "spec",
        metavar="SPEC",
        help="object selector"
    )
    update_parser.add_argument(
        "keyvals",
        metavar="KEY=VAL",
        nargs="*",
        help="key and new value"
    )

    # Add refresh sub-command.
    refresh_parser = subparsers.add_parser("refresh", help="Refresh cache")
    refresh_parser.set_defaults(func=action_refresh)

    # Parse command line arguments.
    args = arg_parser.parse_args()

    # Read config file.
    config = ConfigParser.RawConfigParser()
    config.readfp(open(args.config))

    # Create a connection to CoreCommerce.
    cc_browser = cctools.CCBrowser(
        config.get("website", "host"),
        config.get("website", "site"),
        config.get("website", "username"),
        config.get("website", "password"),
        cache_ttl = 0 if args.func == action_refresh else args.cache_ttl,
        verbose=args.verbose
        #,proxy="localhost:8080"  # allow MITM debugging
    )

    # Perform the action.
    try:
        args.func(args, cc_browser)
    except ArgumentError as ae:
        arg_parser.error(ae)

    return 0


if __name__ == "__main__":
    main()
