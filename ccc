#!/usr/bin/env python2
# -*- mode: Python -*-

"""
Command line tool for CoreCommerce access.

TODO
----
* --filter needs work
** better name
** allow FIELD=REGEX?
** apply to list
*** does this mean show sub-command goes away?
* fix update sub-command
"""

from __future__ import print_function
import ConfigParser
import argparse
import cctools
import json
import os
import re
import sys

HEADER_MAP = {
    "Available": "Avail",
    "Discontinued Item": "Discd",
    "Track Inventory": "TrkInv",
    "Inventory Level": "InvLvl",
    "Category Id": "CatId",
    "Product SKU": "PrdSKU",
    "Required": "QReq",
    "Track Inventory": "TrkInv",
    "Question Enabled": "QEnab",
    "Answer Sort Order": "Sort",
    "Inventory Level": "InvLvl",
    "Answer Input Type": "AnsType"
}

PRODUCT_ABBREVS = ["product", "pro"]
CATEGORY_ABBREVS = ["category", "cat"]
PERSONALIZATION_ABBREVS = ["personalization", "per"]

class ArgumentError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)


def output_csv(args, records, fields, header_map=None):
    """Output records in CSV format."""
    delim = args.delimiter

    # Output header.
    if header_map == None:
        header_map = dict()
    print(delim.join([header_map.get(field, field) for field in fields]))

    # Output records.
    for record in records:
        print(
            delim.join([
                cctools.html_to_plain_text(record.get(field, ""))
                for field in fields
            ])
        )


def output_table_divider(col_widths):
    print(
        "+" + "+".join(
            "-" * (col_width + 2)
            for col_width in col_widths
        ) + "+"
    )


def output_table_row(row, col_widths, mapping=None):
    if mapping == None:
        mapping = dict()
    print(
        "| " + " | ".join(
            "%-*s" % (col_widths[col], mapping.get(field, field))
            for col, field in enumerate(row)
        ) + " |"
    )


def output_table(records, fields, header_map=None):
    """Output records in ASCII table format."""
    if header_map == None:
        header_map = dict()

    # Determine the column widths.
    col_widths = list()
    for field in fields:
        col_widths.append(len(header_map.get(field, field)))
    for record in records:
        for col, field in enumerate(fields):
            col_widths[col] = max(
                col_widths[col],
                len(str(record.get(field, "")))
            )

    # Pretty print the records to the output.
    output_table_divider(col_widths)
    output_table_row(fields, col_widths, header_map)
    output_table_divider(col_widths)
    for row, record in enumerate(records):
        output_table_row(
            [
                cctools.html_to_plain_text(record.get(field, ""))
                for field in fields
            ],
            col_widths
        )
    output_table_divider(col_widths)


def output_json(args, records, fields, header_map=None):
    """Output records in JSON format."""
    mapped_records = []
    for record in records:
        mapped_record = dict()
        for (key, value) in record.items():
            if key in fields:
                mapped_record[key] = value
        mapped_records.append(mapped_record)

    print(
        json.dumps(
            mapped_records,
            check_circular=False,
            indent=2,
            separators=(',', ': '),
            sort_keys=True
        )
    )


def output_records(args, records, fields, header_map=None):
    if args.format == "csv":
        output_csv(args, records, fields, header_map)
    elif args.format == "json":
        output_json(args, records, fields, header_map)
    elif args.format == "table":
        output_table(records, fields, header_map)


def reverse_lookup_header_map(header_map, value):
    """Return key from header_map that maps to value."""
    for key in header_map:
        if value == header_map[key]:
            return key
    return value


def get_output_fields(args, default_fields, objects):
    """Return list of fields to output."""
    if args.fields == "all":
        # All fields, but put the default fields in front.
        fields = default_fields + [
            field for field in sorted(objects[0].keys())
            if field not in default_fields
        ]
    elif args.fields == "default":
        fields = default_fields
    else:
        fields = [
            reverse_lookup_header_map(HEADER_MAP, field)
            for field in args.fields.split(",")
        ]
    return fields


def action_list(args, cc_browser):
    """List objects of a type."""
    if args.obj_type == "product":
        products = cc_browser.get_products()
        if args.filter:
            reo = re.compile(args.filter, re.IGNORECASE)
            products = [
                p for p in products
                if reo.search(p["SKU"]) or reo.search(p["Product Name"])
            ]
        products = sorted(products, key=lambda x: x["SKU"])
        fields = get_output_fields(
            args,
            [
                "SKU",
                "Product Name",
                "Cost",
                "Price",
                "Available",
                "Discontinued Item",
                "Track Inventory",
                "Inventory Level",
                "Teaser"
            ],
            products
        )
        output_records(args, products, fields, HEADER_MAP)

    elif args.obj_type == "category":
        categories = cc_browser.get_categories()
        categories = sorted(categories, key=lambda x: x["Sort"])
        fields = get_output_fields(
            args,
            ["Category Id", "Category Name", "Sort", "Thumbnail"],
            categories
        )
        output_records(args, categories, fields, HEADER_MAP)

    elif args.obj_type == "personalization":
        personalizations = cc_browser.get_personalizations()
        personalizations = sorted(
            personalizations,
            key=cc_browser.personalization_sort_key
        )
        fields = get_output_fields(
            args,
            [
                "Product SKU",
                "SKU",
                "Product Name",
                "Answer Input Type",
                "Answer Sort Order",
                "Question|Answer",
                "Question Enabled",
                "Required",
                "Track Inventory",
                "Inventory Level",
                "Main Photo"
            ],
            personalizations
        )
        output_records(args, personalizations, fields, HEADER_MAP)


def action_list_fields(args, cc_browser):
    """List fields of a type."""
    if args.obj_type == "product":
        products = cc_browser.get_products()
        field_names = sorted(products[0].keys())
    elif args.obj_type == "category":
        categories = cc_browser.get_categories()
        field_names = sorted(categories[0].keys())
    elif args.obj_type == "personalization":
        personalizations = cc_browser.get_personalizations()
        field_names = sorted(personalizations[0].keys())
    fields = ["Field Name"]
    records = list()
    for field_name in field_names:
        records.append({"Field Name": field_name})
    output_records(args, records, fields)


def find_object(args, cc_browser):
    """Return an object iff there is one object matched by spec."""
    if args.obj_type == "product":
        objects = cc_browser.get_products()
        keys = ["SKU", "Product Name"]
    elif args.obj_type == "category":
        objects = cc_browser.get_categories()
        keys = ["Category Name"]
    elif args.obj_type == "personalization":
        objects = cc_browser.get_personalizations()
        keys = ["Question|Answer"]

    found_obj = None
    for obj in objects:
        for key in keys:
            if obj[key].startswith(args.spec):
                if found_obj:
                    raise ArgumentError(
                        "'{}' does not uniquely select a {}".format(
                            args.spec,
                            args.obj_type
                        )
                    )
                found_obj = obj
    if found_obj == None:
        raise ArgumentError(
            "No {} matches '{}' = '{}'".format(
                args.obj_type,
                "' or '".join(keys),
                args.spec
            )
        )

    return found_obj


def print_obj(obj, key):
    """Print obj[key] if key is defined, otherwise print entire dict."""
    if key:
        print(obj[key])
    else:
        for key, value in obj.items():
            print("{}: {}".format(key, value))

def action_show(args, cc_browser):
    """Show attributes of a specific object."""
    object = find_object(args, cc_browser)
    print_obj(object, args.key)


def action_update(args, cc_browser):
    """Update attributes of a specific object."""
    object = find_object(args, cc_browser)
    for keyval in args.keyvals:
        split_key_value = keyval.split("=")
        if len(split_key_value) != 2:
            raise ArgumentError("Invalid KEY=VALUE '{}'".format(keyval))
        key = split_key_value[0]
        if not cc_browser.is_valid_product_update_key(key):
            raise ArgumentError(
                "Invalid key '{}'. Only {} can be modified".format(
                    key,
                    cc_browser.get_product_update_keys()
                )
            )
        value = split_key_value[1]
        #print("{} {} {}->{}".format(object["SKU"], key, object[key], value))
        cc_browser.update_product(object["SKU"], key, value)


def action_refresh(args, cc_browser):
    """Refresh CoreCommerce object cache."""
    if not args.obj_type or args.obj_type == "product":
        print("Refreshing products")
        cc_browser.get_products()

    if not args.obj_type or args.obj_type == "category":
        print("Refreshing categories")
        cc_browser.get_categories()

    if not args.obj_type or args.obj_type == "personalization":
        print("Refreshing personalizations")
        cc_browser.get_personalizations()


def add_format_args(arg_parser):
    """Add formatting args to arg_parser."""
    arg_parser.add_argument(
        "--format",
        choices=["csv", "json", "table"],
        default="table",
        help="output format [csv, json, table] (default=%(default)s)"
    )
    arg_parser.add_argument(
        "--delimiter",
        dest="delimiter",
        metavar="DELIM",
        default="|",
        help="output CSV delimiter (default=%(default)s)"
    )


def add_obj_type_argument(arg_parser, nargs=None):
    """Add object type argument to arg_parser."""
    arg_parser.add_argument(
        "obj_type",
        choices=PRODUCT_ABBREVS + CATEGORY_ABBREVS + PERSONALIZATION_ABBREVS,
        nargs=nargs,
        help="optional object type" if nargs == "?" else "object type"
    )


def normalize_obj_type(args):
    if args.obj_type:
        if args.obj_type in PRODUCT_ABBREVS:
            args.obj_type = "product"
        elif args.obj_type in CATEGORY_ABBREVS:
            args.obj_type = "category"
        elif args.obj_type in PERSONALIZATION_ABBREVS:
            args.obj_type = "personalization"


def main():
    """main"""
    default_config = os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        "cctools.cfg"
    )

    arg_parser = argparse.ArgumentParser(
        description="Command line tool for CoreCommerce access."
    )
    arg_parser.add_argument(
        "--config",
        metavar="FILE",
        default=default_config,
        help="configuration filename (default=%(default)s)"
    )
    arg_parser.add_argument(
        "--verbose",
        action="store_true",
        default=False,
        help="display progress messages"
    )
    subparsers = arg_parser.add_subparsers(title="sub-commands")

    # Add list sub-command.
    list_parser = subparsers.add_parser(
        "list",
        #python3 aliases=["li"],
        help="list objects"
    )
    list_parser.set_defaults(func=action_list)
    list_parser.add_argument(
        "--fields",
        metavar="FIELD_LIST",
        default="default",
        help="list of fields to output"
    )
    list_parser.add_argument(
        "--filter",
        dest="filter",
        metavar="RE",
        help="filter items"
    )
    add_format_args(list_parser)
    add_obj_type_argument(list_parser)

    # Add list_fields sub-command.
    list_fields_parser = subparsers.add_parser("list_fields", help="list object fields")
    list_fields_parser.set_defaults(func=action_list_fields)
    add_format_args(list_fields_parser)
    add_obj_type_argument(list_fields_parser)

    # Add show sub-command.
    show_parser = subparsers.add_parser(
        "show",
        #python3 aliases=["sh"],
        help="list key, values of an object"
    )
    show_parser.set_defaults(func=action_show)
    add_obj_type_argument(show_parser)
    show_parser.add_argument(
        "spec",
        metavar="SPEC",
        help="object selector"
    )
    show_parser.add_argument(
        "key",
        metavar="KEY",
        nargs="?",
        help="optional specific key to show"
    )

    # Add update sub-command.
    update_parser = subparsers.add_parser(
        "update",
        #python3 aliases=["up"],
        help="update values of an object"
    )
    update_parser.set_defaults(func=action_update)
    add_obj_type_argument(update_parser)
    update_parser.add_argument(
        "spec",
        metavar="SPEC",
        help="object selector"
    )
    update_parser.add_argument(
        "keyvals",
        metavar="KEY=VAL",
        nargs="*",
        help="key and new value"
    )

    # Add refresh sub-command.
    refresh_parser = subparsers.add_parser(
        "refresh",
        #python3 aliases=["re"],
        help="refresh cache"
    )
    refresh_parser.set_defaults(func=action_refresh)
    add_obj_type_argument(refresh_parser, nargs="?")

    # Parse command line arguments.
    args = arg_parser.parse_args()
    normalize_obj_type(args)

    # Read config file.
    config = ConfigParser.RawConfigParser()
    config.readfp(open(args.config))

    # Create a connection to CoreCommerce.
    cc_browser = cctools.CCBrowser(
        config.get("website", "host"),
        config.get("website", "site"),
        config.get("website", "username"),
        config.get("website", "password"),
        cache_ttl = 0 if args.func == action_refresh else 3600,
        verbose=args.verbose
        #,proxy="localhost:8080"  # allow MITM debugging
    )

    # Perform the action.
    try:
        args.func(args, cc_browser)
    except ArgumentError as ae:
        arg_parser.error(ae)

    return 0


if __name__ == "__main__":
    main()
