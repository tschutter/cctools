#!/usr/bin/env python2
# -*- mode: Python -*-

"""
Command line tool for CoreCommerce access.
"""

from __future__ import print_function
import ConfigParser
import argparse
import cctools
import json
import logging
import notify_send_handler
import operator
import os
import re

# Define canonical object types.
PRODUCT = "product"
CATEGORY = "category"
PERSONALIZATION = "personalization"

# Specify abbreviations for object types.
PRODUCT_ABBREVS = [PRODUCT, "products", "prod"]
CATEGORY_ABBREVS = [CATEGORY, "categories", "cat"]
PERSONALIZATION_ABBREVS = [PERSONALIZATION, "pers"]


# In some output formats (such as table), it is helpful to have
# abbreviated column headers.  This is true especially for boolean
# values like "Available" and "Discontinued Item".
HEADER_MAP = {
    "Available": "Avail",
    "Discontinued Item": "Discd",
    "Track Inventory": "TrkInv",
    "Inventory Level": "InvLvl",
    "Category Id": "CatId",
    "Product SKU": "PrdSKU",
    "Required": "QReq",
    "Question Enabled": "QEnab",
    "Answer Sort Order": "Sort",
    "Answer Input Type": "AnsType"
}


def canonicalize_field_name(field):
    """Given a field name or abbreviation, return the field name."""
    for key in HEADER_MAP:
        if field == HEADER_MAP[key]:
            return key
    return field


class ArgumentError(Exception):
    """Class to hold info about an argument error."""
    def __init__(self, value):
        super(ArgumentError, self).__init__()
        self.value = value

    def __str__(self):
        return repr(self.value)


def output_csv(args, records, fields, header_map=None):
    """Output records in CSV format."""
    delim = args.delimiter

    # Output header.
    if header_map is None:
        header_map = dict()
    print(delim.join([header_map.get(field, field) for field in fields]))

    # Output records.
    for record in records:
        print(
            delim.join([
                cctools.html_to_plain_text(record.get(field, ""))
                for field in fields
            ])
        )


def output_table_divider(col_widths):
    """Print a horizontal table divider."""
    print(
        "+" + "+".join(
            "-" * (col_width + 2)
            for col_width in col_widths
        ) + "+"
    )


def output_table_row(row_values, col_widths, mapping=None):
    """Print a single row of a table."""
    if mapping is None:
        mapping = dict()
    print(
        "| " + " | ".join(
            "{0:{1}}".format(mapping.get(field, field), col_widths[col])
            for col, field in enumerate(row_values)
        ) + " |"
    )


def output_table(records, fields, header_map=None):
    """Output records in ASCII table format."""
    if header_map is None:
        header_map = dict()

    # Determine the column widths.
    col_widths = list()
    for field in fields:
        col_widths.append(len(header_map.get(field, field)))
    for record in records:
        for col, field in enumerate(fields):
            col_widths[col] = max(
                col_widths[col],
                len(str(record.get(field, "")))
            )

    # Pretty print the records to the output.
    output_table_divider(col_widths)
    output_table_row(fields, col_widths, header_map)
    output_table_divider(col_widths)
    for record in records:
        output_table_row(
            [
                cctools.html_to_plain_text(record.get(field, ""))
                for field in fields
            ],
            col_widths
        )
    output_table_divider(col_widths)


def output_json(records, fields, header_map=None):
    """Output records in JSON format."""
    mapped_records = []
    for record in records:
        mapped_record = dict()
        for (key, value) in record.items():
            if key in fields:
                mapped_record[key] = value
        mapped_records.append(mapped_record)

    print(
        json.dumps(
            mapped_records,
            check_circular=False,
            indent=2,
            separators=(',', ': '),
            sort_keys=True
        )
    )


def output_records(args, records, fields, header_map=None):
    """Output records based upon args.format."""
    if args.format == "csv":
        output_csv(args, records, fields, header_map)
    elif args.format == "json":
        output_json(records, fields, header_map)
    elif args.format == "table":
        output_table(records, fields, header_map)


def get_default_fields(args, config):
    # Look for default fields in config file.
    if config.has_section("ccc"):
        option = "default_{}_fields".format(args.obj_type)
        for name, value in config.items("ccc"):
            if name == option:
                return [
                    x.strip()
                    for x in value.split(",")
                ]

    if args.obj_type == PRODUCT:
        return [
            "Category",
            "Product Name",
            "SKU",
            "Cost",
            "Price",
            "Available",
            "Discontinued Item",
            "Track Inventory",
            "Inventory Level",
            "Teaser"
        ]

    elif args.obj_type == CATEGORY:
        return ["Sort", "Category Name", "Thumbnail"]

    elif args.obj_type == PERSONALIZATION:
        return [
            "Product SKU",
            "SKU",
            "Product Name",
            "Answer Input Type",
            "Answer Sort Order",
            "Question|Answer",
            "Question Enabled",
            "Required",
            "Track Inventory",
            "Inventory Level",
            "Main Photo"
        ]


def get_output_fields(args, config, objects):
    """Return list of fields to output."""
    if args.fields == "all":
        default_fields = get_default_fields(args, config)
        # All fields, but put the default fields in front.
        fields = default_fields + [
            field for field in sorted(objects[0].keys())
            if field not in default_fields
        ]

    elif args.fields == "default":
        fields = get_default_fields(args, config)

    else:
        fields = [
            canonicalize_field_name(field)
            for field in args.fields.split(",")
        ]

    return fields


def get_objects(args, cc_browser):
    """Get and filter objects from the cc_browser."""
    if args.obj_type == PRODUCT:
        objects = cc_browser.get_products()

    elif args.obj_type == CATEGORY:
        objects = cc_browser.get_categories()

    elif args.obj_type == PERSONALIZATION:
        objects = cc_browser.get_personalizations()

    if args.filter:
        for filter in args.filter:
            field, regex = filter.split("=")
            field = canonicalize_field_name(field)
            regex = re.compile(regex, re.IGNORECASE)
            objects = [p for p in objects if regex.search(p[field])]

    return objects


def action_list(args, config, cc_browser):
    """List objects of a type."""
    objects = get_objects(args, cc_browser)
    fields = get_output_fields(args, config, objects)
    if args.obj_type == PERSONALIZATION:
        objects = sorted(
            objects,
            key=cc_browser.personalization_sort_key
        )
    else:
        objects = sorted(objects, key=operator.itemgetter(*fields))
    output_records(args, objects, fields, HEADER_MAP)


def action_list_fields(args, config, cc_browser):
    """List fields of a type."""
    if args.obj_type == PRODUCT:
        products = cc_browser.get_products()
        field_names = sorted(products[0].keys())
    elif args.obj_type == CATEGORY:
        categories = cc_browser.get_categories()
        field_names = sorted(categories[0].keys())
    elif args.obj_type == PERSONALIZATION:
        personalizations = cc_browser.get_personalizations()
        field_names = sorted(personalizations[0].keys())

    fields = ["Field Name"]
    records = list()
    for field_name in field_names:
        records.append({"Field Name": field_name})
    output_records(args, records, fields)


def find_object(args, cc_browser):
    """Return an object iff there is one object matched by spec."""
    if args.obj_type == PRODUCT:
        objects = cc_browser.get_products()
        keys = ["SKU", "Product Name"]
    elif args.obj_type == CATEGORY:
        objects = cc_browser.get_categories()
        keys = ["Category Name"]
    elif args.obj_type == PERSONALIZATION:
        objects = cc_browser.get_personalizations()
        keys = ["Question|Answer"]

    found_obj = None
    for obj in objects:
        for key in keys:
            if obj[key].startswith(args.spec):
                if found_obj:
                    raise ArgumentError(
                        "'{}' does not uniquely select a {}".format(
                            args.spec,
                            args.obj_type
                        )
                    )
                found_obj = obj
    if found_obj is None:
        raise ArgumentError(
            "No {} matches '{}' = '{}'".format(
                args.obj_type,
                "' or '".join(keys),
                args.spec
            )
        )

    return found_obj


def action_update(args, config, cc_browser):
    """Update attributes of objects."""
    objects = get_objects(args, cc_browser)
    if len(objects) == 0:
        raise ArgumentError("No matching {}".format(args.obj_type))
    elif len(objects) > 1:
        print("WARNING: About to modify {} objects.".format(len(objects)))

    for obj in objects:
        for keyval in args.keyvals:
            split_key_value = keyval.split("=")
            if len(split_key_value) != 2:
                raise ArgumentError("Invalid KEY=VALUE '{}'".format(keyval))
            key = split_key_value[0]
            if not cc_browser.is_valid_product_update_key(key):
                raise ArgumentError(
                    "Invalid key '{}'. Only {} can be modified".format(
                        key,
                        cc_browser.get_product_update_keys()
                    )
                )
            value = split_key_value[1]
            print(
                "{} {} {}->{}".format(obj["SKU"], key, obj[key], value)
            )
            # cc_browser.update_product(obj["SKU"], key, value)


def action_refresh(args, config, cc_browser):
    """Refresh CoreCommerce object cache."""
    if not args.obj_type or args.obj_type == PRODUCT:
        print("Refreshing products")
        cc_browser.get_products()

    if not args.obj_type or args.obj_type == CATEGORY:
        print("Refreshing categories")
        cc_browser.get_categories()

    if not args.obj_type or args.obj_type == PERSONALIZATION:
        print("Refreshing personalizations")
        cc_browser.get_personalizations()


def add_format_args(arg_parser):
    """Add formatting args to arg_parser."""
    arg_parser.add_argument(
        "--format",
        choices=["csv", "json", "table"],
        default="table",
        help="output format (default=%(default)s)"
    )
    arg_parser.add_argument(
        "--delimiter",
        dest="delimiter",
        metavar="DELIM",
        default="|",
        help="output CSV delimiter (default=%(default)s)"
    )


def add_obj_type_argument(arg_parser, nargs=None):
    """Add object type argument to arg_parser."""
    arg_parser.add_argument(
        "obj_type",
        choices=PRODUCT_ABBREVS + CATEGORY_ABBREVS + PERSONALIZATION_ABBREVS,
        nargs=nargs,
        help="optional object type" if nargs == "?" else "object type"
    )


def normalize_obj_type(args):
    if args.obj_type:
        if args.obj_type in PRODUCT_ABBREVS:
            args.obj_type = PRODUCT
        elif args.obj_type in CATEGORY_ABBREVS:
            args.obj_type = CATEGORY
        elif args.obj_type in PERSONALIZATION_ABBREVS:
            args.obj_type = PERSONALIZATION


def main():
    """main"""
    default_config = os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        "cctools.cfg"
    )

    arg_parser = argparse.ArgumentParser(
        description="Command line tool for CoreCommerce access."
    )
    arg_parser.add_argument(
        "--config",
        metavar="FILE",
        default=default_config,
        help="configuration filename (default=%(default)s)"
    )
    arg_parser.add_argument(
        "--verbose",
        action="store_true",
        default=False,
        help="display progress messages"
    )
    arg_parser.add_argument(
        "--notify-send",
        action="store_true",
        default=False,
        help="display progress messages via notify-send(1)"
    )
    subparsers = arg_parser.add_subparsers(title="sub-commands")

    # Add list sub-command.
    list_parser = subparsers.add_parser(
        "list",
        # python3 aliases=["li"],
        help="list objects"
    )
    list_parser.set_defaults(func=action_list)
    add_format_args(list_parser)
    add_obj_type_argument(list_parser)
    list_parser.add_argument(
        "--fields",
        metavar="FIELD_LIST",
        default="default",
        help="CSV list of fields to output, or 'all'"
    )
    list_parser.add_argument(
        "--filter",
        dest="filter",
        action="append",
        metavar="FIELD=RE",
        help="filter items based on regular expression"
    )

    # Add list_fields sub-command.
    list_fields_parser = subparsers.add_parser(
        "list_fields",
        help="list object fields"
    )
    list_fields_parser.set_defaults(func=action_list_fields)
    add_format_args(list_fields_parser)
    add_obj_type_argument(list_fields_parser)

    # Add update sub-command.
    update_parser = subparsers.add_parser(
        "update",
        # python3 aliases=["up"],
        help="update values of an object"
    )
    update_parser.set_defaults(func=action_update)
    add_obj_type_argument(update_parser)
    update_parser.add_argument(
        "--filter",
        dest="filter",
        action="append",
        metavar="FIELD=RE",
        help="filter items based on regular expression"
    )
    update_parser.add_argument(
        "keyvals",
        metavar="KEY=VAL",
        nargs="+",
        help="key and new value"
    )

    # Add refresh sub-command.
    refresh_parser = subparsers.add_parser(
        "refresh",
        # python3 aliases=["re"],
        help="refresh cache"
    )
    refresh_parser.set_defaults(func=action_refresh)
    add_obj_type_argument(refresh_parser, nargs="?")

    # Parse command line arguments.
    args = arg_parser.parse_args()
    normalize_obj_type(args)

    # Configure logging.
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)  # lowest level of all handlers
    logger.handlers = []
    handler = logging.StreamHandler()
    handler.setLevel(logging.INFO if args.verbose else logging.WARNING)
    logger.addHandler(handler)

    if args.notify_send:
        # Also log using notify-send if it is available.
        if notify_send_handler.NotifySendHandler.is_available():
            logger.addHandler(
                notify_send_handler.NotifySendHandler(
                    os.path.splitext(os.path.basename(__file__))[0],
                    level=logging.INFO
                )
            )

    # Read config file.
    config = ConfigParser.RawConfigParser()
    config.readfp(open(args.config))

    # Create a connection to CoreCommerce.
    cc_browser = cctools.CCBrowser(
        config.get("website", "host"),
        config.get("website", "site"),
        config.get("website", "username"),
        config.get("website", "password"),
        cache_ttl=0 if args.func == action_refresh else 3600,
        # ,proxy="localhost:8080"  # allow MITM debugging
    )

    # Perform the action.
    try:
        args.func(args, config, cc_browser)
    except ArgumentError as argument_error:
        arg_parser.error(argument_error)

    return 0


if __name__ == "__main__":
    main()
