#!/usr/bin/env python

"""
Command line tool for CoreCommerce access.
"""

import ConfigParser
import cctools
import optparse
import os
import sys

HEADER_MAP = {
    "Available": "Avail",
    "Track Inventory": "TrkInv",
    "Inventory Level": "InvLvl",
    "Category Id": "CatId",
    "Product SKU": "PrdSKU",
    "Required": "QuesReq",
    "Track Inventory": "TrkInv",
    "Question Enabled": "QEnab",
    "Answer Sort Order": "Sort",
    "Inventory Level": "InvLvl",
    "Answer Input Type": "AnsType"
}

def output_csv(options, records, fields, header_map=None):
    """Output records in CSV format."""
    delim = options.delimiter

    # Output header.
    if header_map == None:
        header_map = dict()
    print(delim.join([header_map.get(field, field) for field in fields]))

    # Output records.
    for record in records:
        print(
            delim.join(
                [cctools.html_to_plain_text(record[field]) for field in fields]
            )
        )


def output_table_divider(col_widths):
    print(
        "+" + "+".join(
            "-" * (col_width + 2)
            for col_width in col_widths
        ) + "+"
    )


def output_table_row(row, col_widths, mapping=None):
    if mapping == None:
        mapping = dict()
    print(
        "| " + " | ".join(
            "%-*s" % (col_widths[col], mapping.get(field, field))
            for col, field in enumerate(row)
        ) + " |"
    )


def output_table(records, fields, header_map=None):
    if header_map == None:
        header_map = dict()

    # Determine the column widths.
    col_widths = list()
    for field in fields:
        col_widths.append(len(header_map.get(field, field)))
    for record in records:
        for col, field in enumerate(fields):
            col_widths[col] = max(col_widths[col], len(str(record[field])))

    # Pretty print the records to the output.
    output_table_divider(col_widths)
    output_table_row(fields, col_widths, header_map)
    output_table_divider(col_widths)
    for row, record in enumerate(records):
        output_table_row(
            [cctools.html_to_plain_text(record[field]) for field in fields],
            col_widths
        )
    output_table_divider(col_widths)


def output_records(options, records, fields, header_map=None):
    if options.format == "csv":
        output_csv(options, records, fields, header_map)
    elif options.format == "table":
        output_table(records, fields, header_map)


def parse_object_type(option_parser, arg):
    """Determine the requested object type."""
    if "product".startswith(arg) and len(arg) > 1:
        return "product"
    elif "category".startswith(arg):
        return "category"
    elif "personalization".startswith(arg) and len(arg) > 1:
        return "personalization"
    else:
        option_parser.error("invalid object type '%s'" % arg)


def reverse_lookup_header_map(header_map, value):
    """Return key from header_map that maps to value."""
    for key in header_map:
        if value == header_map[key]:
            return key
    return None


def adjust_field_list(fields, option_parser, options, header_map):
    """Add and remove fields from field list."""

    # Remove fields specified by --del-field.
    if options.del_fields:
        for del_field in options.del_fields:
            if del_field == "*":
                del fields[:]
            elif del_field in fields:
                fields.remove(del_field)
            else:
                # Try the mapped form.
                del_field2 = reverse_lookup_header_map(header_map, del_field)
                if del_field2 in fields:
                    fields.remove(del_field2)
                else:
                    option_parser.error(
                        "field '%s' to delete not found" % del_field
                    )

    # Add fields specified by --add-field.
    if options.add_fields:
        for add_field in options.add_fields:
            if add_field in fields:
                option_parser.error(
                    "field '%s' to add already in field list" % add_field
                )
            else:
                fields.append(add_field)


def action_list(option_parser, options, args, cc_browser):
    """List objects of a type."""
    if len(args) < 2:
        option_parser.error("object type not specified")
    elif len(args) > 2:
        option_parser.error("invalid argument")
    obj_type = parse_object_type(option_parser, args[1])
    if obj_type == "product":
        products = cc_browser.get_products()
        products = sorted(products, key=lambda x: x["SKU"])
        fields = [
            "SKU",
            "Product Name",
            "Cost",
            "Price",
            "Available",
            "Track Inventory",
            "Inventory Level",
            "Teaser"
        ]
        adjust_field_list(fields, option_parser, options, HEADER_MAP)
        output_records(options, products, fields, HEADER_MAP)
    elif obj_type == "category":
        categories = cc_browser.get_categories()
        categories = sorted(categories, key=lambda x: x["Sort"])
        fields = ["Category Id", "Category Name", "Sort"]
        adjust_field_list(fields, option_parser, options, HEADER_MAP)
        output_records(options, categories, fields, HEADER_MAP)
    elif obj_type == "personalization":
        personalizations = cc_browser.get_personalizations()
        personalizations = sorted(
            personalizations,
            key=cc_browser.personalization_sort_key
        )
        fields = [
            "Product SKU",
            "SKU",
            "Product Name",
            "Question|Answer",
            "Required",
            "Track Inventory",
            "Question Enabled",
            "Answer Sort Order",
            "Inventory Level",
            "Answer Input Type",
            "Main Photo"
        ]
        output_records(options, personalizations, fields, HEADER_MAP)


def action_list_fields(option_parser, options, args, cc_browser):
    """List fields of a type."""
    if len(args) < 2:
        option_parser.error("object type not specified")
    elif len(args) > 2:
        option_parser.error("invalid argument")
    obj_type = parse_object_type(option_parser, args[1])
    if obj_type == "product":
        products = cc_browser.get_products()
        field_names = sorted(products[0].keys())
    elif obj_type == "category":
        categories = cc_browser.get_categories()
        field_names = sorted(categories[0].keys())
    elif obj_type == "personalization":
        personalizations = cc_browser.get_personalizations()
        field_names = sorted(personalizations[0].keys())
    fields = ["Field Name"]
    records = list()
    for field_name in field_names:
        records.append({"Field Name": field_name})
    output_records(options, records, fields)


def find_object(option_parser, obj_type, objects, spec, keys):
    """Return an object iff there is one object matched by spec."""
    found_obj = None
    for obj in objects:
        for key in keys:
            if obj[key].startswith(spec):
                if found_obj:
                    option_parser.error(
                        "'%s' does not uniquely select one of the %s" % (
                            spec,
                            obj_type
                        )
                    )
                found_obj = obj
    if found_obj == None:
        option_parser.error("No %s match '%s'" % (obj_type, spec))
    return found_obj


def print_obj(obj, key):
    """Print obj[key] if key is defined, otherwise print entire dict."""
    if key:
        print obj[key]
    else:
        for key, value in obj.iteritems():
            print "%s: %s" % (key, value)


def action_show(option_parser, options, args, cc_browser):
    """Show attributes of a specific object."""
    if len(args) < 2:
        option_parser.error("object type not specified")
    elif len(args) < 3:
        option_parser.error("SPEC not specified")
    elif len(args) > 4:
        option_parser.error("invalid argument")
    obj_type = parse_object_type(option_parser, args[1])
    spec = args[2]
    if len(args) < 4:
        key = None
    else:
        key = args[3]
    if obj_type == "product":
        products = cc_browser.get_products()
        product = find_object(
            option_parser,
            obj_type,
            products,
            spec,
            ["SKU", "Product Name"]
        )
        print_obj(product, key)

    elif obj_type == "category":
        categories = cc_browser.get_categories()
        category = find_object(
            option_parser,
            obj_type,
            categories,
            spec,
            ["Category Name"]
        )
        print_obj(category, key)

    elif obj_type == "personalization":
        personalizations = cc_browser.get_personalizations()
        personalization = find_object(
            option_parser,
            obj_type,
            personalizations,
            spec,
            ["Question|Answer"]
        )
        print_obj(personalization, key)


def update_obj(option_parser, options, product, key_values, cc_browser):
    """Update attributes of a specific object."""
    for key_value in key_values:
        split_key_value = key_value.split("=")
        if len(split_key_value) != 2:
            option_parser.error("Invalid KEY=VALUE '%s'" % key_value)
        key = split_key_value[0]
        if not cc_browser.is_valid_product_update_key(key):
            option_parser.error("Invalid KEY '%s'" % key)
        value = split_key_value[1]
        #print "%s %s %s->%s\n" % (product["SKU"], key, product[key], value)
        cc_browser.update_product(product["SKU"], key, value)


def action_update(option_parser, options, args, cc_browser):
    """Update attributes of a specific object."""
    if len(args) < 2:
        option_parser.error("object type not specified")
    elif len(args) < 3:
        option_parser.error("SPEC not specified")
    elif len(args) < 4:
        option_parser.error("KEY=VALUE not specified")
    obj_type = parse_object_type(option_parser, args[1])
    spec = args[2]
    if obj_type == "product":
        products = cc_browser.get_products()
        product = find_object(
            option_parser,
            obj_type,
            products,
            spec,
            ["SKU", "Product Name"]
        )
        update_obj(option_parser, options, product, args[3:], cc_browser)

    elif obj_type == "category":
        categories = cc_browser.get_categories()
        category = find_object(
            option_parser,
            obj_type,
            categories,
            spec,
            ["Category Name"]
        )
        update_obj(option_parser, options, category, args[3:], cc_browser)

    elif obj_type == "personalization":
        personalizations = cc_browser.get_personalizations()
        personalization = find_object(
            option_parser,
            obj_type,
            personalizations,
            spec,
            ["Question|Answer"]
        )
        update_obj(
            option_parser,
            options,
            personalization,
            args[3:],
            cc_browser
        )


def main():
    """main"""
    default_config = os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        "cctools.cfg"
    )

    option_parser = optparse.OptionParser(
        usage="usage: %prog [options] action\n" +
        "  Actions:\n" +
        "    list { product | category | personalization }\n"
        "      List objects in table form.\n"
        "    show { product | category | personalization } SPEC [KEY]\n"
        "      List key, values of an object.\n"
        "    update { product | category | personalization } SPEC KEY=VAL ...\n"
        "      Update values of an object."
    )
    option_parser.add_option(
        "--config",
        metavar="FILE",
        default=default_config,
        help="configuration filename (default=%default)"
    )
    option_parser.add_option(
        "--refresh-cache",
        action="store_true",
        default=False,
        help="refresh cache from website"
    )
    option_parser.add_option(
        "--cache-ttl",
        metavar="SEC",
        default=3600,
        help="cache TTL (default=%default)"
    )
    option_parser.add_option(
        "--format",
        choices=["csv", "table"],
        default="table",
        help="output format [csv, table] (default=%default)"
    )
    option_parser.add_option(
        "--delimiter",
        dest="delimiter",
        metavar="DELIM",
        default="|",
        help="output CSV delimiter (default=%default)"
    )
    option_parser.add_option(
        "--verbose",
        action="store_true",
        default=False,
        help="display progress messages"
    )

    list_group = optparse.OptionGroup(
        option_parser,
        "list options",
        "List objects."
    )
    list_group.add_option(
        "--add-field",
        action="append",
        dest="add_fields",
        metavar="FLD",
        help="additional field to report"
    )
    list_group.add_option(
        "--del-field",
        action="append",
        dest="del_fields",
        metavar="FLD",
        help="remove field from report"
    )
    option_parser.add_option_group(list_group)

    list_fields_group = optparse.OptionGroup(
        option_parser,
        "list-fields options",
        "List fields."
    )
    option_parser.add_option_group(list_fields_group)

    # Parse command line arguments.
    (options, args) = option_parser.parse_args()

    # Read config file.
    config = ConfigParser.RawConfigParser()
    config.readfp(open(options.config))

    # Create a connection to CoreCommerce.
    cc_browser = cctools.CCBrowser(
        config.get("website", "host"),
        config.get("website", "site"),
        config.get("website", "username"),
        config.get("website", "password"),
        cache_ttl=0 if options.refresh_cache else options.cache_ttl,
        verbose=options.verbose,
        #proxy="localhost:8080"  # allow MITM analysis
    )

    if len(args) < 1:
        option_parser.error("action not specified")
    action = args[0]
    if "list".startswith(action):
        action_list(option_parser, options, args, cc_browser)
    elif "list-fields".startswith(action):
        action_list_fields(option_parser, options, args, cc_browser)
    elif "show".startswith(action):
        action_show(option_parser, options, args, cc_browser)
    elif "update".startswith(action):
        action_update(option_parser, options, args, cc_browser)
    else:
        option_parser.error("invalid action '%s'" % action)

    return 0

if __name__ == "__main__":
    main()
